Since there were no source files, we figured out we had to disassemble /bin/getflag directly to exploit it.

When disassembling the main function, we identified a syscall to the function ptrace.

Dump of assembler code for function main:
0x08048946 <+0>:	push   %ebp
0x08048947 <+1>:	mov    %esp,%ebp
0x08048949 <+3>:	push   %ebx
0x0804894a <+4>:	and    $0xfffffff0,%esp
0x0804894d <+7>:	sub    $0x120,%esp
0x08048953 <+13>:	mov    %gs:0x14,%eax
0x08048959 <+19>:	mov    %eax,0x11c(%esp)
0x08048960 <+26>:	xor    %eax,%eax
0x08048962 <+28>:	movl   $0x0,0x10(%esp)
0x0804896a <+36>:	movl   $0x0,0xc(%esp)
0x08048972 <+44>:	movl   $0x1,0x8(%esp)
0x0804897a <+52>:	movl   $0x0,0x4(%esp)
0x08048982 <+60>:	movl   $0x0,(%esp)
=> 0x08048989 <+67>:	call   0x8048540 <ptrace@plt>
0x0804898e <+72>:	test   %eax,%eax

As we can see here, right after the ptrace syscall, a test instruction checks the value of %eax, basically the return value of ptrace.

We can create a catchpoint for the syscall and modify its return value, like so :

catch syscall ptrace
commands 1
set ($eax) = 0
continue
end

Then we needed a breakpoint at the getuid libcall, so :

(gdb) b getuid
(gdb) r

The uid returned by getuid is stored in eax, and the assignment takes 2 instructions.
So we jump to the next instruction twice, with ni.
Once at the right address, we override the value of %eax :

(gdb) set $eax = 3014

This is the uid of flag14.

Hitting continue (or c) outputs :

(gdb) c
Continuing.
Check flag.Here is your token : 7QiHafiNa3HVozsaXkawuYrTstxbpABHD8CPnHJ
[Inferior 1 (process 2133) exited normally]
